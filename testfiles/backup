
Match Semantic::match(const TokenType token)
{
    bool                         error       = false;
    bool                         cached      = false;
    bool                         matched     = false;
    bool                         goon        = false;
    uint32_t                     position    = 0;
    uint32_t                     key_counter = 0;
    SemanticType                 stype       = SemanticType::UNDEFINED;
    SemanticNode                 snode;
    std::set<SemanticType>       new_key_cache;
    SemanticNode::const_iterator found;
    SemanticNode::const_iterator wildcard;

    if (_cache.data.size() == 0)
    {
        for (const auto& pair : _streams) 
        {
            _cache.keys.insert(pair.first);
        }
    }
    else
    {
        cached = true;
    }

    for (const auto& key : _cache.keys) 
    {   
        const auto& value = _streams[key];
        position          = cached ? _cache.data[key] : 0;

        if (position < value.size())
        {
            auto& node     = value[position];
                  found    = std::find(node.begin(), node.end(), token);
                  wildcard = std::find(node.begin(), node.end(), TokenType::ANY);
                  snode    = node;

            if ( (found != node.end()))
            {
                _cache.data[key] = ++position;
                matched          = (position == value.size());
                goon             = true;

                if (matched) stype = key;

                if (_cache.keys.size() == _streams.size())
                {
                    new_key_cache.insert(key);
                }
            }
            else if (wildcard != node.end())
            {
                position++;
                auto& lookahead  = value[position];

                found            = std::find(lookahead.begin(), lookahead.end(), token);
                position         = (found == lookahead.end()) ? position - 1 : position + 1;
                _cache.data[key] = position;
                matched          = (position == value.size());

                if (matched) stype = key;
            }
            else
            {
                if (goon)
                {
                    if (new_key_cache.size() == 0)
                    {
                        new_key_cache = _cache.keys;
                    }
                    new_key_cache.erase(key);
                }
                else if ((key_counter + 1) == _cache.keys.size())
                {
                    error = true;
    
                    if (cached)
                    {
                        _cache.reset();
                    }

                    break;
                }
            }
        }

        ++key_counter;
    }

    if (new_key_cache.size())
    {
        _cache.keys = new_key_cache;
    }

    if (matched) 
    {
        _cache.reset();
    }

    return { matched, stype, { Token{}, snode, error } };
}
